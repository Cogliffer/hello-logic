
<style>
    end {
        display: block;
        text-align: right;
        position: relative;
        top: -20px;
    }
</style>

careful $\veebar$ 排斥但至少一个成立

$\mathbb{R}$ con not be coded to $\mathbb{N}$, how to compute on the real number?

*computable function*
- *zero function* $\mathbf{0}(x) = 0, \forall x\in\mathbb{N}$.
- *successor function* $s(x) = x + 1, \forall x\in\mathbb{N}$.
- *projection function* $\pi_{i}(x_1,x_2,\cdots,x_n) = x_{i}, x_i\in\mathbb{N}, \forall i = 1,2,\ldots,n$.

*standard program*
- If for every Jump instruction $J(a,b,c)$ on program $P = (p_1,p_2,\cdots,p_n)$ always holds that $c\le n+1$, then $P$ is a *standard program*.

*lemma*
- for every converge program $P$, there exists a standard program $P'$ such that they have the same computable function.
Proof. Assume $P=(p_1,p_2,\cdots,p_n)$, just replace the Jump instruction $J(a,b,c)$ with $J(a,b,n+1)$ if $c>n+1$. They are equal since $J(a,b,c),J(a,b,n+1)$ all lead to stop.
$P' = (p^{'}_1,p^{'}_2,\cdots,p^{'}_n), \text{where }
p^{'}_i = \begin{cases}
    J(a,b,n+1) & \text{if } p_i = J(a,b,c), c>n+1 \\
    p_i & \text{otherwise}.
\end{cases}$

*join*
- if program $P=(p_1,p_2,\cdots,p_n)$ and another program $Q=(q_1,q_2,\cdots,q_m)$, then program $PQ$ is defined by $PQ = (p^{'}_1,p^{'}_2,\cdots,p^{'}_n,q^{'}_1,q^{'}_2,\cdots,q^{'}_m)$ where $P' = (p^{'}_1,p^{'}_2,\cdots,p^{'}_n)$ is the standard program of $P$ and $q_{i}^{'} = \begin{cases}
    J(a,b,c+n) & \text{if } q_i = J(a,b,c) \\
    q_i & \text{otherwise}.
\end{cases}$

*subprogram*
- for every program $P=(p_1,p_2,\cdots,p_n)$, there exists a smallest number $\rho(P)$ such that $\forall u>\rho(P)$ register $R_u$ never used when the running of program $P$.
- $P[l_1,l_2,\cdots,l_n\rightarrow l] \equiv_{def} (T(l_1,1),T(l_2,2),\cdots,T(l_n,n),Z(n+1),Z(n+2),\cdots,Z(\rho(P)),P,T(1,l))$
1| $T(l_1,1),T(l_2,2),\cdots,T(l_n,n)$
2| $Z(n+1),Z(n+2),\cdots,Z(\rho(P))$
3| $P$
4| $T(1,l)$
generally, $\forall\rho\in\mathbb{N}, P[l_1,l_2,\cdots,l_n\rightarrow l:\rho] \equiv_{def} (T(l_1,1),T(l_2,2),\cdots,T(l_n,n),Z(n+1),Z(n+2),\cdots,Z(\rho),P,T(1,l))$

**Theorem** The composition of computable functions is computable.
Proof. Assume $\boldsymbol{x} = (x_1,x_2,\cdots,x_n),\boldsymbol{y} = (y_1,y_2,\cdots,y_m)$ and function $f(\boldsymbol{x})$ and $g_1(\boldsymbol{y}),g_2(\boldsymbol{y}),\cdots,g_n(\boldsymbol{y})$ are computabel. Assume program $P(\boldsymbol{x})\downarrow f(\boldsymbol{x})$ and $Q_1(\boldsymbol{y})\downarrow g_1(\boldsymbol{y}),Q_2(\boldsymbol{y})\downarrow g_2(\boldsymbol{y}),\cdots,Q_n(\boldsymbol{y})\downarrow g_n(\boldsymbol{y})$. We will show that the function $f(g_1(\boldsymbol{y}),g_2(\boldsymbol{y}),\cdots,g_n(\boldsymbol{y}))$ is computabel.

$\rho\equiv_{def} \mathrm{Max}\{\rho(P),\rho(Q_1),\rho(Q_2),\cdots,\rho(Q_n)\}$

set the $\boldsymbol{y}$ as initial configuration.
1| $T(1,\rho+1),T(2,\rho+2),\cdots,T(m,\rho+m)$
2| $Q_1[\rho+1,\rho+2,\cdots,\rho+m\rightarrow\rho+m+1:\rho],Q_2[\rho+1,\rho+2,\cdots,\rho+m\rightarrow\rho+m+2:\rho],\cdots,Q_n[\rho+1,\rho+2,\cdots,\rho+m\rightarrow\rho+m+n:\rho]$
3| $P[\rho+m+1,\rho+m+2,\cdots,\rho+m+n\rightarrow 1:\rho]$ <end>$\Box$</end>
*recursion function*
**Defination** Given any functions $f(\boldsymbol{x}),g(\boldsymbol{x},k,l),\boldsymbol{x} = (x_1,x_2,\cdots,x_n)$ there is a *recursion function* $h(\boldsymbol{x},k)$ defined by
$$
\begin{align*}
    & h(\boldsymbol{x},0) = f(\boldsymbol{x}) \\
    & h(\boldsymbol{x},k+1) = g(\boldsymbol{x},k,h(\boldsymbol{x},k))
\end{align*}
$$


**Theorem** The recursion function $h(\boldsymbol{x},k)$ defined by computable function $f(\boldsymbol{x}),g(\boldsymbol{x},k,l),\boldsymbol{x} = (x_1,x_2,\cdots,x_n)$ is computable.
Proof. Assume program $P(\boldsymbol{x})\downarrow f(\boldsymbol{x}),Q(\boldsymbol{x},k,l)\downarrow g(\boldsymbol{x},k,l)$
$\rho = \mathrm{Max}(\rho(P),\rho(Q))$
set the $(\boldsymbol{x},k)$ as initial configuration.
1| $T(1,\rho+1),T(2,\rho+2),\cdots,T(n,\rho+n),T(n+1,\rho+n+1)$
2| $P[\rho+1,\rho+2,\cdots,\rho+n\rightarrow\rho+n+2:\rho]$
3| $Z(\rho+n+3)$
4| $J(\rho+n+1,\rho+n+3,8)$
5| $Q(\rho+1,\rho+2,\cdots,\rho+n+2\rightarrow\rho+n+2:\rho)$
6| $S(\rho+n+3)$
7| $J(1,1,4)$
8| $T(\rho+n+2,1)$

function generated by substitution and recursion also is total function

*normal computable function*
$x+y$. $\mathit{Proof}$. $f(x)=x,g(x,y,z)=z+1,h(x,y)$.
$xy$
$x^y$ 
$x-1=\begin{cases}
    x-1 & x>1 \\
    0 & x=0
\end{cases}$
$x-y=\begin{cases}
    x-y & x\ge y \\
    0 & \text{otherwise}
\end{cases}$
$sg(x)=\begin{cases}
    1 & x\neq 0 \\
    0 & x=0
\end{cases}$
$\overline{sg}(x)=\begin{cases}
    1 & x=0 \\
    0 & x\neq 0
\end{cases}$
$|x-y|$
$x!$
$\mathrm{min}(x,y)$
$\mathrm{max}(x,y)$
$\mathrm{rm}(x,y)=$ remainder when $y$ is divided by $x$.
$\mathrm{qt}(x,y)=$ quotient when $y$ is divided by $x$.
$\mathrm{div}(x,y)=\begin{cases}
    1 & x\mid y\\
    0 & x\nmid y
\end{cases}$

*piecewise function*
$f_1(\boldsymbol{x}),f_2(\boldsymbol{x}),\cdots,f_n(\boldsymbol{x})$
$M_1(\boldsymbol{x}),M_2(\boldsymbol{x}),\cdots,M_n(\boldsymbol{x})$, $M_1(\boldsymbol{x})\veebar M_2(\boldsymbol{x})\veebar \cdots\veebar M_n(\boldsymbol{x})$
$$g(\boldsymbol{x})=\begin{cases}
    f_1(\boldsymbol{x}) & if M_1(\boldsymbol{x})\ holds\\
    f_2(\boldsymbol{x}) & if M_2(\boldsymbol{x})\ holds\\
    \quad \vdots & \quad \quad\vdots\\
    f_n(\boldsymbol{x}) & if M_n(\boldsymbol{x})\ holds\\
\end{cases}$$

*Algebra of decidability*
$DP(M(\boldsymbol{x})),DP(Q(\boldsymbol{x}))$
$\neg M(\boldsymbol{x}), \neg Q(\boldsymbol{x})$
$M(\boldsymbol{x})\wedge Q(\boldsymbol{x})$
$M(\boldsymbol{x})\vee Q(\boldsymbol{x})$

*bounded minimalisation*
any function $f(\boldsymbol{x},y)$
$\sum_{z<y}f(\boldsymbol{x},z)$ recursive defined by
$$\begin{align*}
    &\sum_{z<0}f(\boldsymbol{x},z) = 0\\
    &\sum_{z<y+1}f(\boldsymbol{x},z) 
        = \sum_{z<y}f(\boldsymbol{x},z) + f(\boldsymbol{x},y)
\end{align*}$$
$\prod_{z<y}f(\boldsymbol{x},z)$ recursive defined by
$$\begin{align*}
    &\prod_{z<0}f(\boldsymbol{x},z) = 1\\
    &\prod_{z<y+1}f(\boldsymbol{x},z) 
        = \big(\prod_{z<y}f(\boldsymbol{x},z)\big) \cdot f(\boldsymbol{x},y)
\end{align*}$$


$TC(f(\boldsymbol{x},z))\Rightarrow Computable(\sum_{z<y}f(\boldsymbol{x},z)),Computable(\prod_{z<y}f(\boldsymbol{x},z))$

$TC(f(\boldsymbol{x},z))\wedge TC(k(\boldsymbol{x},s))\Rightarrow Computable(\sum_{z<k(\boldsymbol{x},s)}f(\boldsymbol{x},z)),Computable(\prod_{z<k(\boldsymbol{x},s)}f(\boldsymbol{x},z))$


*$\mu$-operator*
any function $f(\boldsymbol{x},z)$
$g(\boldsymbol{x},y)=\begin{cases}
    \mu z<y(f(\boldsymbol{x},z)=0)& if\ z\ exist\\
    y&if\ z\ not\ exist
\end{cases}$

$TC(f(\boldsymbol{x},z))\Rightarrow Computable(\mu z<y(f(\boldsymbol{x},z)=0))$

$TC(f(\boldsymbol{x},z)),TC(k(\boldsymbol{x},s))\Rightarrow Computable(\mu z<k(\boldsymbol{x},s)(f(\boldsymbol{x},z)=0))$

$$\begin{align*}DP(R(\boldsymbol{x},y))\Rightarrow
    &Computable(\mu z<yR(\boldsymbol{x},z))\\
    &\&DP(\forall z<yR(\boldsymbol{x},z))\\
    &\&DP(\exist z<yR(\boldsymbol{x},z))\\
\end{align*}$$


4.15 attention


*(unbounded) minimalisation*
any function $f(\boldsymbol{x},z)$
$$g(\boldsymbol{x})=\begin{cases}
    \mu z(f(\boldsymbol{x},z)=0)& if\ z\ exist\\
    null &if\ z\ not\ exist
\end{cases}$$

**Theorem**
$Computable(f(\boldsymbol{x},z))\Rightarrow Computable(\mu z(f(\boldsymbol{x},z)=0))$
$Computable(g(\boldsymbol{x}))???$

obgect:name,type,content,proof

$DP(M(\boldsymbol{x},z))$
$$g(\boldsymbol{x})=\begin{cases}
    \mu zM(\boldsymbol{x},z)& if\ z\ exist\\
    null &if\ z\ not\ exist
\end{cases}$$

**Theorem**
$DP(M(\boldsymbol{x},z))\Rightarrow Computable(\mu zM(\boldsymbol{x},z))$
$Computable(g(\boldsymbol{x}))???$

function generated by minimalisation on total function is not total function

*primitive recursive* total function can be built up from the basic functions using substitution and recursion only.

minimalissation is independent from substitution and recursion.

循环加判断算法，等价于，特征函数的求和和求积函数???是否有更广泛的对应？？如何一般化这个关系？？直觉？？